<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Page 4 of 10 for Justin’s Blurgh</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Justin’s Blurgh" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://blog.presidentbeef.com/blog/4/" />
<meta property="og:url" content="https://blog.presidentbeef.com/blog/4/" />
<meta property="og:site_name" content="Justin’s Blurgh" />
<meta property="og:type" content="website" />
<link rel="prev" href="https://blog.presidentbeef.com/blog/3/" />
<link rel="next" href="https://blog.presidentbeef.com/blog/5/" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Justin’s Blurgh" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"Justin’s Blurgh","url":"https://blog.presidentbeef.com/blog/4/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://blog.presidentbeef.com/feed.xml" title="Justin&apos;s Blurgh" />
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Justin&#39;s Blurgh</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/archives/">Archives</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="blog-index">
  
  
  
    <article style='border-bottom-width: 4px; border-bottom-style: solid; padding-top: 3em; padding-bottom: 2em'>
      
  <header>
    
      <h1 class="entry-title" style="font-size: 2.6em; line-height: 1.2em;"><a href="/blog/2022/01/24/dragon-ruby-render-targets/">DragonRuby: Render Targets</a></h1>
    
    
      <p class="meta">
        







<time datetime="2022-01-24T11:00:00-07:00" pubdate data-updated="true" style="color: #a2a2a2">Jan 24th, 2022</time>
      </p>
    
  </header>


  <div class="entry-content"><p>Next up in my notes on <a href="https://dragonruby.itch.io/dragonruby-gtk">DragonRuby</a>: render targets!</p>

<p>Weirdly, the <a href="http://docs.dragonruby.org/#----advanced-rendering---simple-render-targets---main-rb">documentation on DragonRuby’s render targets</a> is limited to example code. Personally, I prefer prose when I am trying to learn… so here we are!</p>

<p>In DragonRuby, a render target is like an infinite canvas you can render as many regular sprites onto as you want, then manipulate the whole thing as if it is one sprite.</p>

<p>This is especially good for things like tiled backgrounds that are built once and do not change.</p>

<p>Let’s take an example.</p>

<h2 id="clouds">Clouds!</h2>

<p>Let’s start off very simple and build up.</p>

<p>First, here’s all the code to render a single 250x250 pixel image to the screen:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tick</span> <span class="n">args</span>
  <span class="n">clouds</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">x: </span><span class="mi">0</span><span class="p">,</span>
    <span class="ss">y: </span><span class="mi">0</span><span class="p">,</span>
    <span class="ss">h: </span><span class="mi">250</span><span class="p">,</span>
    <span class="ss">w: </span><span class="mi">250</span><span class="p">,</span>
    <span class="ss">path: </span><span class="s1">'sprites/cloud.png'</span>
  <span class="p">}</span>

  <span class="n">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">sprites</span> <span class="o">&lt;&lt;</span> <span class="n">clouds</span>
<span class="k">end</span>
</code></pre></div></div>

<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/o4bpadbxwln2zp3gsuai.png" alt="Single cloud tile" /></p>

<h3 id="more-clouds">More Clouds</h3>

<p>Cool, but I’d like to fill the whole window with clouds, so I’m going to tile them.</p>

<p>The code below makes a 6x3 grid of the cloud image.</p>

<p>(In DragonRuby, the screen is always 1280x720. Our grid is 1500x750 but I’m not trying to be too precise with the numbers here.)</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tick</span> <span class="n">args</span>
  <span class="n">clouds</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="mi">6</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">y</span><span class="o">|</span>
      <span class="n">clouds</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
        <span class="ss">x: </span><span class="n">x</span> <span class="o">*</span> <span class="mi">250</span><span class="p">,</span>
        <span class="ss">y: </span><span class="n">y</span> <span class="o">*</span> <span class="mi">250</span><span class="p">,</span>
        <span class="ss">h: </span><span class="mi">250</span><span class="p">,</span>
        <span class="ss">w: </span><span class="mi">250</span><span class="p">,</span>
        <span class="ss">path: </span><span class="s1">'sprites/cloud.png'</span>
      <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">sprites</span> <span class="o">&lt;&lt;</span> <span class="n">clouds</span>
<span class="k">end</span>
</code></pre></div></div>

<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/o99o7jjmnfxupewak1n9.png" alt="Screen full of blue clouds" /></p>

<p>Ah… blue clouds. Nice.</p>

<p>On every tick, the code builds up an array of 18 sprites (images) and renders it out to the screen.</p>

<p>(There are a number of ways to make this more efficient - check out the <a href="https://dev.to/presidentbeef/series/16166">previous posts</a> in this series for different ways to “cache” the sprite information.)</p>

<h3 id="render-targets">Render Targets</h3>

<p>But in this post we are talking about render targets - which is a way of rendering a bunch of sprites (or any other renderable thing) just once, and then treating the whole group of sprites as a single sprite. This is <em>faster</em>, simpler, and enables some neat effects.</p>

<p>The code only needs minor changes to switch the cloud grid to using a render target instead:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Move cloud grid creation into a helper method</span>
<span class="k">def</span> <span class="nf">make_clouds</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">clouds</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="mi">6</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">y</span><span class="o">|</span>
      <span class="n">clouds</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
        <span class="ss">x: </span><span class="n">x</span> <span class="o">*</span> <span class="mi">250</span><span class="p">,</span>
        <span class="ss">y: </span><span class="n">y</span> <span class="o">*</span> <span class="mi">250</span><span class="p">,</span>
        <span class="ss">h: </span><span class="mi">250</span><span class="p">,</span>
        <span class="ss">w: </span><span class="mi">250</span><span class="p">,</span>
        <span class="ss">path: </span><span class="s1">'sprites/cloud.png'</span>
      <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Similar to `args.outputs`,</span>
  <span class="c1"># render targets have `.sprites`, `.solids`, etc.</span>
  <span class="c1"># The argument will be used as the path below</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">render_target</span><span class="p">(</span><span class="ss">:clouds</span><span class="p">).</span><span class="nf">sprites</span> <span class="o">&lt;&lt;</span> <span class="n">clouds</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="c1"># Set up the render target on the first tick</span>
  <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="nf">tick_count</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">make_clouds</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># Output a single sprite</span>
  <span class="c1"># located at 0,0 and the size of the whole grid</span>
  <span class="c1"># created in `make_clouds`</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">sprites</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
    <span class="ss">x: </span><span class="mi">0</span><span class="p">,</span>
    <span class="ss">y: </span><span class="mi">0</span><span class="p">,</span>
    <span class="ss">w: </span><span class="mi">250</span> <span class="o">*</span> <span class="mi">6</span><span class="p">,</span>
    <span class="ss">h: </span><span class="mi">250</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
    <span class="ss">path: :clouds</span> <span class="c1"># Name of the render target!</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>For convenience, the code above moves the creation of the cloud grid and the render target into a helper method which gets called on the first tick of the game.</p>

<p><code class="language-plaintext highlighter-rouge">args.render_target(:clouds)</code> automatically creates a new render target named <code class="language-plaintext highlighter-rouge">:clouds</code> if it does not already exist. Then we can render things to it just as if it were <code class="language-plaintext highlighter-rouge">args.outputs</code>.</p>

<p>Interestingly, render targets do not seem to have an innate width or height. In order to avoid unintentional scaling, you will need to “know” how big the render target is. In this case, we know it is a 6x3 grid of 250x250 images, so the size is fairly straightforward. I left the math in to make it clearer.</p>

<p>Finally, we reference the render target similarly to an image file, but pass in the name of the render target as the <code class="language-plaintext highlighter-rouge">:path</code> instead of an actual file path.</p>

<h2 id="static-sprites-too">Static Sprites, Too!</h2>

<p><a href="https://blog.presidentbeef.com/blog/2022/01/08/dragon-ruby-static-outputs/">As explored in a different post</a>, we can use <code class="language-plaintext highlighter-rouge">static_sprites</code> to “render” the sprite <em>once</em>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># No changes here</span>
<span class="k">def</span> <span class="nf">make_clouds</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">clouds</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="mi">6</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="mi">3</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">y</span><span class="o">|</span>
      <span class="n">clouds</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
        <span class="ss">x: </span><span class="n">x</span> <span class="o">*</span> <span class="mi">250</span><span class="p">,</span>
        <span class="ss">y: </span><span class="n">y</span> <span class="o">*</span> <span class="mi">250</span><span class="p">,</span>
        <span class="ss">h: </span><span class="mi">250</span><span class="p">,</span>
        <span class="ss">w: </span><span class="mi">250</span><span class="p">,</span>
        <span class="ss">path: </span><span class="s1">'sprites/cloud.png'</span>
      <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">args</span><span class="p">.</span><span class="nf">render_target</span><span class="p">(</span><span class="ss">:clouds</span><span class="p">).</span><span class="nf">sprites</span> <span class="o">&lt;&lt;</span> <span class="n">clouds</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="nf">tick_count</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">make_clouds</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># Create the clouds sprite once</span>
    <span class="c1"># and keep it in `args.state`.</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">clouds</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">x: </span><span class="mi">0</span><span class="p">,</span>
      <span class="ss">y: </span><span class="mi">0</span><span class="p">,</span>
      <span class="ss">w: </span><span class="mi">250</span> <span class="o">*</span> <span class="mi">6</span><span class="p">,</span>
      <span class="ss">h: </span><span class="mi">250</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
      <span class="ss">path: :clouds</span>
    <span class="p">}</span>

    <span class="c1"># Add the clouds sprite just once</span>
    <span class="c1"># as a "static" sprite</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">static_sprites</span> <span class="o">&lt;&lt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">clouds</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And now we can move the clouds around just by changing the attributes on the render target.</p>

<p>Adding a little bit of code at the end of <code class="language-plaintext highlighter-rouge">tick</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">clouds</span><span class="p">.</span><span class="nf">x</span> <span class="o">=</span> <span class="p">(</span><span class="no">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="nf">tick_count</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-</span> <span class="mi">100</span>
</code></pre></div></div>

<p>(The calculation and numbers aren’t really important here, I just fiddled around until something looked decent.)</p>

<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hw1qpqotbcg6pfpqo2bq.gif" alt="Clouds moving back and forth" /></p>

<p>Oh hey! Those extra pixels on the sides of the cloud grid actually came in handy.</p>

<h3 id="what-else">What Else?</h3>

<p>Remember, the entire render target is like one sprite now. That means all the regular sprite attributes (e.g. color, size, blending, flipping, rotation) can be applied to the entire thing at once.</p>

<p><em>Wait, did you say rotation?</em></p>

<p>Sure, let’s make ourselves dizzy.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">clouds</span><span class="p">.</span><span class="nf">angle</span> <span class="o">=</span> <span class="p">(</span><span class="no">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="nf">tick_count</span> <span class="o">/</span> <span class="mi">120</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/g5n2ug9ehwbn8yzh2orq.gif" alt="Spinning clouds" /></p>

<p>Okay, that’s as deep as we’ll go on render targets in this post!</p>
</div>


    </article>
  
  
    <article style='border-bottom-width: 4px; border-bottom-style: solid; padding-top: 3em; padding-bottom: 2em'>
      
  <header>
    
      <h1 class="entry-title" style="font-size: 2.6em; line-height: 1.2em;"><a href="/blog/2022/01/15/a-object-oriented-starter-for-dragonruby/">DragonRuby: Object-Oriented Starter</a></h1>
    
    
      <p class="meta">
        







<time datetime="2022-01-15T11:00:00-07:00" pubdate data-updated="true" style="color: #a2a2a2">Jan 15th, 2022</time>
      </p>
    
  </header>


  <div class="entry-content"><p>I enjoy playing with the <a href="https://dragonruby.itch.io/dragonruby-gtk">DragonRuby Game Toolkit</a>, but the <a href="http://docs.dragonruby.org/">documentation</a> and many of the examples are very much intended for non-Rubyists. Additionally, as a game engine, it’s more data/functionally-oriented than most Rubyists are used to. For example, the main game loop in the <code class="language-plaintext highlighter-rouge">tick</code> method needs to be implemented as a top-level method.</p>

<p>This post walks through structuring a game in a way that is a little more familiar to Rubyists.</p>

<p><em>Caveat!</em> I am new to DragonRuby myself and this is not meant to be the “correct” or “best” or even “great” way to organize your code. It’s just a pattern I’ve started using and it might be useful for you!</p>

<p>(By the way, while DragonRuby is a commercial product, you can often <a href="https://dragonruby.itch.io/dragonruby-gtk">grab a free copy</a>. Keep an eye out for sales!)</p>

<h3 id="starting-example">Starting Example</h3>

<p>First, let’s start with some code that isn’t using any class definitions at all. Everything happens inside <code class="language-plaintext highlighter-rouge">tick</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="c1"># Set up player object</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">player</span> <span class="o">||=</span> <span class="p">{</span>
    <span class="ss">x: </span><span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
    <span class="ss">y: </span><span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
    <span class="ss">w: </span><span class="mi">20</span><span class="p">,</span>
    <span class="ss">h: </span><span class="mi">20</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="c1"># Move player based on keyboard input</span>
  <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="nf">inputs</span><span class="p">.</span><span class="nf">keyboard</span><span class="p">.</span><span class="nf">left</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">player</span><span class="p">.</span><span class="nf">x</span> <span class="o">-=</span> <span class="mi">10</span>
  <span class="k">elsif</span> <span class="n">args</span><span class="p">.</span><span class="nf">inputs</span><span class="p">.</span><span class="nf">keyboard</span><span class="p">.</span><span class="nf">right</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">player</span><span class="p">.</span><span class="nf">x</span> <span class="o">+=</span> <span class="mi">10</span>
  <span class="k">elsif</span> <span class="n">args</span><span class="p">.</span><span class="nf">inputs</span><span class="p">.</span><span class="nf">keyboard</span><span class="p">.</span><span class="nf">down</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">player</span><span class="p">.</span><span class="nf">y</span> <span class="o">-=</span> <span class="mi">10</span>
  <span class="k">elsif</span> <span class="n">args</span><span class="p">.</span><span class="nf">inputs</span><span class="p">.</span><span class="nf">keyboard</span><span class="p">.</span><span class="nf">up</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">player</span><span class="p">.</span><span class="nf">y</span> <span class="o">+=</span> <span class="mi">10</span>
  <span class="k">end</span>

  <span class="c1"># Render the "player" as a square to the screen</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">solids</span> <span class="o">&lt;&lt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">player</span>
<span class="k">end</span>
</code></pre></div></div>

<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/79w79at48p6lh0zeo08r.gif" alt="DragonRuby Example - Moving a black square around" /></p>

<p>As a reminder, DragonRuby automatically loads up code from a file called <code class="language-plaintext highlighter-rouge">mygame/app/main.rb</code> and then calls <code class="language-plaintext highlighter-rouge">tick</code> 60 times per second.</p>

<p><code class="language-plaintext highlighter-rouge">args.state</code> is like an OpenStruct where you can add on whatever attributes you want and store whatever you would like. In this case, we add a hash that we name <code class="language-plaintext highlighter-rouge">player</code>.</p>

<p>The code then checks for keyboard input and adjusts the position of the “player”. (To keep things very simple, we don’t worry about keeping the player on the screen.)</p>

<p>Finally, we render the “player” as a solid square.</p>

<p>This is simple enough and the code isn’t too complicated. But, just for fun, let’s slowly transform it to be a little more “object-oriented”.</p>

<h3 id="game-object">Game Object</h3>

<p>First, let’s create a main “game” object to hold our logic, instead of putting it all in <code class="language-plaintext highlighter-rouge">tick</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyGame</span>
  <span class="c1"># Adds convenience methods for args, gtk, keyboard, etc.</span>
  <span class="n">attr_gtk</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">player</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">x: </span><span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
      <span class="ss">y: </span><span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
      <span class="ss">w: </span><span class="mi">20</span><span class="p">,</span>
      <span class="ss">h: </span><span class="mi">20</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">tick</span>
    <span class="k">if</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">left</span>
      <span class="n">state</span><span class="p">.</span><span class="nf">player</span><span class="p">.</span><span class="nf">x</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">right</span>
      <span class="n">state</span><span class="p">.</span><span class="nf">player</span><span class="p">.</span><span class="nf">x</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">down</span>
      <span class="n">state</span><span class="p">.</span><span class="nf">player</span><span class="p">.</span><span class="nf">y</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">up</span>
      <span class="n">state</span><span class="p">.</span><span class="nf">player</span><span class="p">.</span><span class="nf">y</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">end</span>

    <span class="n">outputs</span><span class="p">.</span><span class="nf">solids</span> <span class="o">&lt;&lt;</span> <span class="n">state</span><span class="p">.</span><span class="nf">player</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">tick</span> <span class="n">args</span>
  <span class="vg">$my_game</span> <span class="o">||=</span> <span class="no">MyGame</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="vg">$my_game</span><span class="p">.</span><span class="nf">args</span> <span class="o">=</span> <span class="n">args</span>
  <span class="vg">$my_game</span><span class="p">.</span><span class="nf">tick</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now the <code class="language-plaintext highlighter-rouge">tick</code> method only sets up the global <code class="language-plaintext highlighter-rouge">$my_game</code> on the first tick, then sets <code class="language-plaintext highlighter-rouge">args</code> on each tick and calls the game’s <code class="language-plaintext highlighter-rouge">tick</code> method.</p>

<p>(<em>Tangent alert!</em> Is it necessary to set <code class="language-plaintext highlighter-rouge">args</code> on every tick? Not strictly - you could set <code class="language-plaintext highlighter-rouge">self.args = args</code> in <code class="language-plaintext highlighter-rouge">initialize</code> and it will work okay. But if you want to use DragonRuby’s unit test framework, it may cause problems because each test has a fresh copy of <code class="language-plaintext highlighter-rouge">args</code>.)</p>

<p>Using <code class="language-plaintext highlighter-rouge">attr_gtk</code> allows the code to be a bit shorter. <code class="language-plaintext highlighter-rouge">args</code>, <code class="language-plaintext highlighter-rouge">state</code>, <code class="language-plaintext highlighter-rouge">keyboard</code>, <a href="http://docs.dragonruby.org/#----attr_gtk-rb">and more</a> now have convenience methods for them.</p>

<h3 id="instance-variables-instead-of-state">Instance Variables Instead of State</h3>

<p><code class="language-plaintext highlighter-rouge">args.state</code> is essentially a global variable space. This is a big convenience when a game is all top-level methods - otherwise you would have to figure out where to stash all your game state yourself.</p>

<p>However, it’s not required to use it.</p>

<p>The code below uses <code class="language-plaintext highlighter-rouge">@player</code> to store the player hash, instead of <code class="language-plaintext highlighter-rouge">args.state</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyGame</span>
  <span class="n">attr_gtk</span>
  <span class="nb">attr_reader</span> <span class="ss">:player</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="vi">@player</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">x: </span><span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
      <span class="ss">y: </span><span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
      <span class="ss">w: </span><span class="mi">20</span><span class="p">,</span>
      <span class="ss">h: </span><span class="mi">20</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">tick</span>
    <span class="k">if</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">left</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">x</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">right</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">x</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">down</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">y</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">up</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">y</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">end</span>

    <span class="n">outputs</span><span class="p">.</span><span class="nf">solids</span> <span class="o">&lt;&lt;</span> <span class="n">player</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">tick</span> <span class="n">args</span>
  <span class="vg">$my_game</span> <span class="o">||=</span> <span class="no">MyGame</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="vg">$my_game</span><span class="p">.</span><span class="nf">args</span> <span class="o">=</span> <span class="n">args</span>
  <span class="vg">$my_game</span><span class="p">.</span><span class="nf">tick</span>
<span class="k">end</span>
</code></pre></div></div>

<p>One thing that has thrown me off with DragonRuby is understanding just how much “regular” Ruby I can use. For the most part, other than how the <code class="language-plaintext highlighter-rouge">tick</code> method is used as the main game loop, you can use the Ruby language constructs you are comfortable with.</p>

<h3 id="splitting-things-up">Splitting Things Up</h3>

<p>No big change here, but as a game grows it’s easier to split the steps of each game loop into different methods.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyGame</span>
  <span class="n">attr_gtk</span>
  <span class="nb">attr_reader</span> <span class="ss">:player</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="vi">@player</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">x: </span><span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
      <span class="ss">y: </span><span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
      <span class="ss">w: </span><span class="mi">20</span><span class="p">,</span>
      <span class="ss">h: </span><span class="mi">20</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">tick</span>
    <span class="n">handle_input</span>
    <span class="n">render</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">handle_input</span>
    <span class="k">if</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">left</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">x</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">right</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">x</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">down</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">y</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">up</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">y</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">render</span>
    <span class="n">outputs</span><span class="p">.</span><span class="nf">solids</span> <span class="o">&lt;&lt;</span> <span class="n">player</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">tick</span> <span class="n">args</span>
  <span class="vg">$my_game</span> <span class="o">||=</span> <span class="no">MyGame</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="vg">$my_game</span><span class="p">.</span><span class="nf">args</span> <span class="o">=</span> <span class="n">args</span>
  <span class="vg">$my_game</span><span class="p">.</span><span class="nf">tick</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="player-class">Player Class</h3>

<p>Final step in this post - let’s move the “player” out to a separate class.</p>

<p>In this example, it might not make a lot of sense. But in most games there will be a lot of state and logic you might want to associate with the “player” or any other objects in the game. Having it be its own class helps keep the logic in one place.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyGame</span>
  <span class="n">attr_gtk</span>
  <span class="nb">attr_reader</span> <span class="ss">:player</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="vi">@player</span> <span class="o">=</span> <span class="no">Player</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">tick</span>
    <span class="n">handle_input</span>
    <span class="n">render</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">handle_input</span>
    <span class="k">if</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">left</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">x</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">right</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">x</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">down</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">y</span> <span class="o">-=</span> <span class="mi">10</span>
    <span class="k">elsif</span> <span class="n">keyboard</span><span class="p">.</span><span class="nf">up</span>
      <span class="n">player</span><span class="p">.</span><span class="nf">y</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">render</span>
    <span class="n">outputs</span><span class="p">.</span><span class="nf">solids</span> <span class="o">&lt;&lt;</span> <span class="n">player</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Player</span>
  <span class="n">attr_sprite</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="vi">@x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="vi">@y</span> <span class="o">=</span> <span class="n">y</span>
    <span class="vi">@w</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="vi">@h</span> <span class="o">=</span> <span class="mi">20</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">tick</span> <span class="n">args</span>
  <span class="vg">$my_game</span> <span class="o">||=</span> <span class="no">MyGame</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="vg">$my_game</span><span class="p">.</span><span class="nf">args</span> <span class="o">=</span> <span class="n">args</span>
  <span class="vg">$my_game</span><span class="p">.</span><span class="nf">tick</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here the code uses another DragonRuby convenience. <code class="language-plaintext highlighter-rouge">attr_sprite</code> adds a bunch of <a href="http://docs.dragonruby.org/#----attr_sprite-rb">helper methods</a> that allow you to use any object as a sprite/solid/border, etc. (Note that the code still passes <code class="language-plaintext highlighter-rouge">player</code> into <code class="language-plaintext highlighter-rouge">outputs.solids</code> and DragonRuby treats it as a solid. If it were passed into <code class="language-plaintext highlighter-rouge">outputs.sprites</code> then it would be treated like a sprite instead!)</p>

<h3 id="separate-files">Separate Files?</h3>

<p>For the sake of a blog post, all the code is together. But there is no reason not to start splitting the code across separate files.</p>

<p>But! In DragonRuby there is one weirdness with <code class="language-plaintext highlighter-rouge">require</code>: you must include the file extension (usually <code class="language-plaintext highlighter-rouge">.rb</code>), while in regular Ruby that is usually omitted.</p>

<h2 id="wrapping-up">Wrapping Up</h2>

<p>Did our code become longer and less straight-forward? Yes, for this small example, definitely.</p>

<p>But as a game (or any project) grows, pulling bits out into modular pieces is going to be an advantage. Personally I fall back on this structure pretty quickly when I start a new DragonRuby project.</p>

<p>Hopefully this post is useful to Rubyists trying to get into DragonRuby!</p>
</div>


    </article>
  
  
    <article style='border-bottom-width: 4px; border-bottom-style: solid; padding-top: 3em; padding-bottom: 2em'>
      
  <header>
    
      <h1 class="entry-title" style="font-size: 2.6em; line-height: 1.2em;"><a href="/blog/2022/01/08/dragon-ruby-static-outputs/">DragonRuby: Static Outputs</a></h1>
    
    
      <p class="meta">
        







<time datetime="2022-01-08T11:00:00-07:00" pubdate data-updated="true" style="color: #a2a2a2">Jan 8th, 2022</time>
      </p>
    
  </header>


  <div class="entry-content"><p>In a <a href="https://dev.to/presidentbeef/api-levels-in-dragonruby-game-toolkit-4jb4">previous post</a> we looked at different ways to render outputs (sprites, rectangles, lines, etc.) in the <a href="https://dragonruby.org/toolkit/game">DragonRuby Game Toolkit</a>.</p>

<p>The post ended by hinting at a more efficient way to render outputs instead of adding them to e.g. <code class="language-plaintext highlighter-rouge">args.outputs.solids</code> or <code class="language-plaintext highlighter-rouge">args.outputs.sprites</code> each tick.</p>

<p>This post explores the world of “static outputs”!</p>

<h2 id="static-what">Static What?</h2>

<p>First of all, we should address the most confusing part of all this.</p>

<p><strong>“Static” does not mean the images don’t move or change.</strong> Instead, it means that render “queue” is not cleared after every tick.</p>

<p>Normally, one would load up the queue each tick, like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tick</span> <span class="n">args</span>

  <span class="c1"># Render a black rectangle</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">solids</span> <span class="o">&lt;&lt;</span> <span class="p">{</span>
    <span class="ss">x: </span><span class="mi">100</span><span class="p">,</span>
    <span class="ss">y: </span><span class="mi">200</span><span class="p">,</span>
    <span class="ss">w: </span><span class="mi">300</span><span class="p">,</span>  <span class="c1"># width</span>
    <span class="ss">h: </span><span class="mi">400</span>   <span class="c1"># height</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>But this is kind of wasteful. We are creating a new hash table each tick (60 ticks/second) and then throwing it away. Also each tick we are filling up the <code class="language-plaintext highlighter-rouge">args.outputs.solids</code> queue and then emptying it.</p>

<p>Instead, why not create the hash table once, load up the queue once, and then re-use them?</p>

<p>That’s the idea of static outputs!</p>

<p>There are static versions for each rendered type:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">args.outputs.static_borders</code></li>
  <li><code class="language-plaintext highlighter-rouge">args.outputs.static_labels</code></li>
  <li><code class="language-plaintext highlighter-rouge">args.outputs.static_primitives</code></li>
  <li><code class="language-plaintext highlighter-rouge">args.outputs.static_solids</code></li>
  <li><code class="language-plaintext highlighter-rouge">args.outputs.static_sprites</code></li>
</ul>

<h2 id="going-static">Going Static</h2>

<h3 id="starting-out">Starting Out</h3>

<p>Here’s an example with comments explaining what the code is doing. This “game” simply moves a square back and forth across the screen. This is the entire program!</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tick</span> <span class="n">args</span>
  <span class="c1"># Initialize the x location of the square</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">x</span> <span class="o">||=</span> <span class="mi">0</span>

  <span class="c1"># Initialize the direction/velocity</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span> <span class="o">||=</span> <span class="mi">10</span>

  <span class="c1"># If we hit the sides, change direction</span>
  <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">x</span> <span class="o">&gt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">right</span> <span class="n">or</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">x</span> <span class="o">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">left</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span> <span class="o">=</span> <span class="o">-</span><span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span>
  <span class="k">end</span>

  <span class="c1"># Update the x location</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">x</span> <span class="o">+=</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span>

  <span class="c1"># Build the square</span>
  <span class="n">square</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">x: </span><span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">x</span><span class="p">,</span>
    <span class="ss">y: </span><span class="mi">400</span><span class="p">,</span>
    <span class="ss">w: </span><span class="mi">40</span><span class="p">,</span>
    <span class="ss">h: </span><span class="mi">40</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="c1"># Add the square to the render queue</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">solids</span> <span class="o">&lt;&lt;</span> <span class="n">square</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The resulting output looks like:</p>

<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/o56m4w483wxr46y07zh0.gif" alt="Image description" /></p>

<p>This example introduces <code class="language-plaintext highlighter-rouge">args.state</code>. This is basically a persistent bag you can throw anything into. (For Rubyists - this is like <a href="https://ruby-doc.org/stdlib-3.1.0/libdoc/ostruct/rdoc/OpenStruct.html">OpenStruct</a>.)</p>

<p><code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">direction</code> are not special, they are just variables we are defining. We use <code class="language-plaintext highlighter-rouge">||=</code> to initialize them because we only want to set the values on the first tick.</p>

<p>This example illustrates the point from above - every tick it creates a new square and adds it to the queue. The queue is emptied out and then the code starts all over again.</p>

<p>Seems wasteful, right?</p>

<h3 id="caching-the-objects">Caching the Objects</h3>

<p>First thing I think of is - “why not create the square once, then just update the object each tick? Does that work?” Yes! It does.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tick</span> <span class="n">args</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span> <span class="o">||=</span> <span class="mi">10</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">square</span> <span class="o">||=</span> <span class="p">{</span>
    <span class="ss">x: </span><span class="mi">0</span><span class="p">,</span>
    <span class="ss">y: </span><span class="mi">400</span><span class="p">,</span>
    <span class="ss">w: </span><span class="mi">40</span><span class="p">,</span>
    <span class="ss">h: </span><span class="mi">40</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">square</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">right</span> <span class="n">or</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">square</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">left</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span> <span class="o">=</span> <span class="o">-</span><span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span>
  <span class="k">end</span>

  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">square</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span>

  <span class="n">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">solids</span> <span class="o">&lt;&lt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">square</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In this code, we create the <code class="language-plaintext highlighter-rouge">square</code> only once and then store it in <code class="language-plaintext highlighter-rouge">args.state.square</code>.</p>

<p>Instead of having a separate <code class="language-plaintext highlighter-rouge">x</code> variable, the code updates the <code class="language-plaintext highlighter-rouge">x</code> property on the square directly.</p>

<p>This is <em>better</em>, but we are still updating <code class="language-plaintext highlighter-rouge">args.outputs.solids</code> each tick.</p>

<h3 id="full-static">Full Static</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tick</span> <span class="n">args</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span> <span class="o">||=</span> <span class="mi">10</span>
  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">square</span> <span class="o">||=</span> <span class="p">{</span>
    <span class="ss">x: </span><span class="mi">0</span><span class="p">,</span>
    <span class="ss">y: </span><span class="mi">400</span><span class="p">,</span>
    <span class="ss">w: </span><span class="mi">40</span><span class="p">,</span>
    <span class="ss">h: </span><span class="mi">40</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="c1"># On the first tick, add the square to the render queue</span>
  <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="nf">tick_count</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">outputs</span><span class="p">.</span><span class="nf">static_solids</span> <span class="o">&lt;&lt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">square</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">square</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">right</span> <span class="n">or</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">square</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="nf">grid</span><span class="p">.</span><span class="nf">left</span>
    <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span> <span class="o">=</span> <span class="o">-</span><span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span>
  <span class="k">end</span>

  <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">square</span><span class="p">[</span><span class="ss">:x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">args</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">direction</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In this code, we use the fact that the first <code class="language-plaintext highlighter-rouge">args.tick_count</code> is <code class="language-plaintext highlighter-rouge">0</code> to add the <code class="language-plaintext highlighter-rouge">square</code> to <code class="language-plaintext highlighter-rouge">args.outputs.static_solids</code> just <em>once</em>. It will continue to be rendered on each tick.</p>

<h2 id="performance">Performance</h2>

<p>Intuitively, since the code is doing less, it should be faster. But does it really make a difference?</p>

<p>It depends on your game, how much it’s doing per tick, how many sprites you are rendering, and what platform/hardware it’s running on.</p>

<p>The examples above? Not going to see any difference using <code class="language-plaintext highlighter-rouge">static_solids</code>.</p>

<p>But DragonRuby contains two examples that directly compare <code class="language-plaintext highlighter-rouge">args.outputs.sprites</code> vs. <code class="language-plaintext highlighter-rouge">args.outputs.static_sprites</code> (<a href="http://docs.dragonruby.org/#----performance---sprites-as-classes---main-rb">here</a> and <a href="http://docs.dragonruby.org/#----performance---static-sprites-as-classes---main-rb">here</a>).</p>

<p>In these examples, you can play with the number of “stars” rendered to see different performance. On my ancient laptop, I do not see a performance difference until around 3,000 stars.</p>

<p>Your mileage may vary, though!</p>

<h2 id="should-i-always-use-the-static-versions">Should I Always Use the Static Versions?</h2>

<p>It depends! Probably not?</p>

<p>If your code mainly manipulates the same objects around the screen <em>and</em> always renders them in the same order, then using the <code class="language-plaintext highlighter-rouge">static_</code> approach might be simpler and faster.</p>

<p>But in many cases it might be easier to simply set up the render queues each tick, especially if the objects rendered or their ordering change regularly. Otherwise, managing the state of the rendering queues can become cumbersome. (We haven’t even talked about clearing the static queues, for example.)</p>

<p>Some of this comes down to personal preference and how you would like to structure your code. But hopefully this post has helped explain how to use the <code class="language-plaintext highlighter-rouge">args.outputs.static_*</code> methods in your game!</p>
</div>


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/5/">&larr; Older</a>
    
    
    <a class="next" href="/blog/3/">Newer &rarr;</a>
    
  </div>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Justin&#39;s Blurgh</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li>
  <a rel="me" href="https://github.com/presidentbeef" target="_blank" title="github">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#github"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://ruby.social/@presidentbeef" target="_blank" title="mastodon">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#mastodon"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://dev.to/presidentbeef/" target="_blank" title="devto">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#devto"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://www.linkedin.com/in/justinscollins/" target="_blank" title="linkedin">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
    </svg>
  </a>
</li>
</ul>
</div>

      <div class="footer-col footer-col-3">
      </div>
    </div>

  </div>

</footer>
</body>

</html>
