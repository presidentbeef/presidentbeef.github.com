<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Justin Collins' Blugh]]></title>
  <link href="http://presidentbeef.github.com/atom.xml" rel="self"/>
  <link href="http://presidentbeef.github.com/"/>
  <updated>2016-06-12T22:51:42-07:00</updated>
  <id>http://presidentbeef.github.com/</id>
  <author>
    <name><![CDATA[Justin Collins]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Automatically Lock Old Closed GitHub Issues]]></title>
    <link href="http://presidentbeef.github.com/blog/2016/06/12/automatically-lock-old-closed-github-issues/"/>
    <updated>2016-06-12T22:27:00-07:00</updated>
    <id>http://presidentbeef.github.com/blog/2016/06/12/automatically-lock-old-closed-github-issues</id>
    <content type="html"><![CDATA[<p>I am not sure this is a problem everyone has, but I grew tired of people commenting on old, resolved GitHub issues.
Almost every time someone would comment &#8220;I have this problem, too&#8221; it would actually be a different issue. Then I&#8217;d
go through the routine of asking them to open a new issue with details about their specific problem.
Sometimes they would, and sometimes they&#8217;d never come back.</p>

<p>Fortunately, right around the time I decided I should do something about this annoyance, <a href="https://developer.github.com/changes/2016-02-11-issue-locking-api/">GitHub released an API</a>
to lock issues. (<a href="https://github.com/blog/1847-locking-conversations">Locking issues or pull requests</a> prevents any new comments except from repo collaborators.)</p>

<p>So I put together a little gem called <a href="https://github.com/presidentbeef/github-auto-locker">github-auto-locker</a> to fetch and lock old, closed issues.</p>

<p>To install it (requires Ruby):</p>

<pre><code>gem install github-auto-locker
</code></pre>

<p>Then run:</p>

<pre><code>github-auto-locker USER REPO TOKEN [age in days]
</code></pre>

<p>For example, I run this to lock resolved issues over 60 days old:</p>

<pre><code>github-auto-locker presidentbeef brakeman N0TM1R34L70K3N 60
</code></pre>

<p>The default is 120 days.</p>

<p>I&#8217;ve been running it periodically myself since February without any complaints.
Perhaps it will be useful to you!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Readers-Writer Lock Gem]]></title>
    <link href="http://presidentbeef.github.com/blog/2014/02/28/simple-readers-writer-lock-gem/"/>
    <updated>2014-02-28T08:53:00-08:00</updated>
    <id>http://presidentbeef.github.com/blog/2014/02/28/simple-readers-writer-lock-gem</id>
    <content type="html"><![CDATA[<p>A <a href="http://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">readers-writer lock</a> can be used to allow many concurrent read-only operations on a resource but ensure exclusive access for modifying operations performed by &#8220;writers&#8221;. For my purposes, I needed a readers-writer lock at the thread level, basically to control access to a shared array. In my scenario, the array is accessed through a server which may server many clients at once. Some requests will be to read elements from the array, while other requests might be adding elements to the array. There is no reason to restrict reads to one client at a time, but elements need to be added while no other client is reading or writing to the array.</p>

<p><a href="https://github.com/presidentbeef/rwlock">My implementation</a> is very simple (the entire <code>RWLock</code> class is 25 lines of code) because it relies on Ruby&#8217;s <a href="http://rdoc.info/stdlib/thread/SizedQueue">SizedQueue</a> class. <code>SizedQueue</code> provides a thread-safe queue with a maximum size. If a thread attempts to add elements to a queue that is full, it will be blocked until an element is removed from the queue to make room. This is a key piece of funtionality used for the readers-writer lock implementation.</p>

<p>The <code>RWLock</code> class only really needs to provide two methods: one to provide read access, and one to provide write access. Since this is Ruby, the methods will take a block to execute the reading/writing code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">RWLock</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">read_sync</span>
</span><span class='line'>    <span class="c1">#lock magic</span>
</span><span class='line'>    <span class="k">yield</span>
</span><span class='line'>    <span class="c1">#lock magic</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">write_sync</span>
</span><span class='line'>    <span class="c1">#lock magic</span>
</span><span class='line'>    <span class="k">yield</span>
</span><span class='line'>    <span class="c1">#lock magic</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The internal state of the lock will be a <code>SizedQueue</code> and a <code>Mutex</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span> <span class="n">max_size</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'>    <span class="vi">@write_lock</span> <span class="o">=</span> <span class="no">Mutex</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>    <span class="vi">@q</span> <span class="o">=</span> <span class="no">SizedQueue</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">max_size</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>SizedQueue</code> will essentially be used as a counting semaphore. Each time a reader enters <code>read_sync</code>, the lock will push an element onto the queue. What the element actually is doesn&#8217;t matter, but I used <code>true</code> because it&#8217;s cheap. If the queue is full, the reader will block until a space has opened up.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">read_sync</span>
</span><span class='line'>    <span class="vi">@q</span><span class="o">.</span><span class="n">push</span> <span class="kp">true</span>
</span><span class='line'>    <span class="k">yield</span>
</span><span class='line'>  <span class="k">ensure</span>
</span><span class='line'>    <span class="vi">@q</span><span class="o">.</span><span class="n">pop</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>When a writer calls <code>write_sync</code>, it synchronizes on the mutex to prevent multiple concurrent writers. Then it adds <em>n</em> elements to the queue, where <em>n</em> is equal to the maximum size of the queue.</p>

<p>This has two effects: first, the writer is forced to wait for all current readers to finish. Second, it essentially prevents any new readers from gaining access (there is a small chance one will sneak in, but the writer will still have to wait for it).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">write_sync</span>
</span><span class='line'>    <span class="vi">@write_lock</span><span class="o">.</span><span class="n">synchronize</span> <span class="k">do</span>
</span><span class='line'>      <span class="vi">@q</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">times</span> <span class="p">{</span> <span class="vi">@q</span><span class="o">.</span><span class="n">push</span> <span class="kp">true</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">begin</span>
</span><span class='line'>        <span class="k">yield</span>
</span><span class='line'>      <span class="k">ensure</span>
</span><span class='line'>        <span class="vi">@q</span><span class="o">.</span><span class="n">clear</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Once the writer is finished, the queue is cleared, allowing all waiting readers to jump in. It is most likely waiting readers will get in before waiting writers, since the write mutex is held while the queue is emptied, but no effort is made to guarantee that one way or another. In practice, though, this seems to balance well between readers and writers.</p>

<p>One obvious downside of this overall approach is the <code>SizedQueue</code> limits the number of concurrent readers. A larger queue will cause writers to wait longer (assuming many readers) while a smaller queue may cause readers to wait on other readers. The upside is readers cannot monopolize the resource and cause writer starvation.</p>

<p>Unfortunately, <code>SizedQueue#clear</code> has been broken forever, since it was simply inherited from <code>Queue</code> and didn&#8217;t actually notify waiting threads that the queue is empty. For some reason, this does not appear to matter in Ruby 1.8, but in Ruby 1.9 and 2.0 it caused a deadlock.</p>

<p>This has been fixed in Ruby 1.9.3p545 and 2.1.1. For broken versions, the <code>RWLock</code> gem monkey-patches <code>SizedQueue</code> to fix the behavior. Unfortunately, Ruby 2.0 also had a bug in <code>SizedQueue#push</code>, so it is completely incompatible. The code does work under JRuby, but there are faster implementations using Java primitives.</p>

<p>RWLock is available as <a href="https://rubygems.org/gems/rwlock">a gem</a> and of course the <a href="https://github.com/presidentbeef/rwlock">code is on GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Brakeman Against 253 Rails Apps]]></title>
    <link href="http://presidentbeef.github.com/blog/2013/11/01/testing-brakeman/"/>
    <updated>2013-11-01T07:54:00-07:00</updated>
    <id>http://presidentbeef.github.com/blog/2013/11/01/testing-brakeman</id>
    <content type="html"><![CDATA[<p>Here is some information about how <a href="http://brakemanscanner.org/">Brakeman</a> is tested!</p>

<h3>Basic Testing and Continuous Integration</h3>

<p>Brakeman does have a few unit tests&#8230;pitifully few. In fact, Brakeman had no tests at all until version <a href="https://github.com/presidentbeef/brakeman/blob/master/CHANGES#L490">0.5.2</a>, nearly a year after Brakeman&#8217;s initial public release. Unit testing Brakeman remains difficult, since much of the code relies on data built up from scanning an entire Rails application.</p>

<p>As such, the majority of tests in Brakeman rely on scanning <a href="https://github.com/presidentbeef/brakeman/tree/master/test/apps">sample applications</a> and checking the resulting reports for an expected set of warnings. There are tests for the presence and absence of specific warnings, as well as checking for the specific number of warnings and an absence of reported errors. Since writing tests is pretty tedious, there is <a href="https://github.com/presidentbeef/brakeman/blob/master/test/to_test.rb">a script</a> which generates the Ruby code to asserts the presence of reported warnings. This script takes the same arguments as Brakeman, so it&#8217;s simple to generate a set of tests for a specific scenario.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">test_information_disclosure_local_request_config</span>
</span><span class='line'>  <span class="n">assert_warning</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:warning</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:warning_code</span> <span class="o">=&gt;</span> <span class="mi">61</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:fingerprint</span> <span class="o">=&gt;</span> <span class="s2">&quot;081f5d87a244b41d3cf1d5994cb792d2cec639cd70e4e306ffe1eb8abf0f32f7&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:warning_type</span> <span class="o">=&gt;</span> <span class="s2">&quot;Information Disclosure&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:message</span> <span class="o">=&gt;</span> <span class="sr">/^Detailed\ exceptions\ are\ enabled\ in\ produ/</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:confidence</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:relative_path</span> <span class="o">=&gt;</span> <span class="s2">&quot;config/environments/production.rb&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The tests run on <a href="https://travis-ci.org/presidentbeef/brakeman">Travis CI</a> which is integrated with GitHub. This is especially helpful for testing compatibility with Ruby 1.8.7, which many Rails applications still run on and Brakeman will probably continue supporting for a long time.</p>

<h3>Regression Testing with a Wide Net</h3>

<p>Unfortunately, the sample applications Brakeman uses for tests are quite limited, not real, and generally just test very specific warnings or previous bugs. To gain higher confidence that Brakeman is not too broken, Brakeman is run against a set of 253 open source Rails applications I have managed to scrape together. (If you have an open source application to add to this test set, please let me know!)</p>

<p>The scans are run on my personal machine - six jobs in parallel, which takes about nine minutes total. After puttering around with a few different approaches, I ended up simply using the <a href="http://rdoc.info/stdlib/thread/Queue">Queue</a> class from Ruby&#8217;s standard library as the job queue. In a Frankenstein combination, a shell script starts up a JRuby process, which builds the Brakeman gem and then runs six threads for scan jobs. Each job launches Brakeman as an external process running under MRI 1.9.3 and, if successful, produces a JSON report. The JSON report is then augmented with some information about the Brakeman commit and the app that was scanned.</p>

<p>When all the apps have been scanned, the JSON reports are tarred up and sent to a server. I use <a href="https://www.digitalocean.com/?refcode=35d9e7aec070">DigitalOcean</a> (referral link!) because I needed an Ubuntu setup and their API lets me use some handy <a href="https://github.com/presidentbeef/my_ocean">scripts</a> to spin the server up and down whenever I need it (and only pay for when it&#8217;s up).</p>

<p>On the server, the reports are unpacked and imported into a <a href="http://rethinkdb.com/">RethinkDB</a> database. Since RethinkDB stores JSON documents, it&#8217;s simple to dump the JSON reports from Brakeman in there. I just have two tables: one just contains commit SHAs and their timestamps, and the other contains the actual reports. I have secondary indexes on the reports to efficiently look them up by the name of the Rails app or the Brakeman SHA.</p>

<p>A small <a href="http://www.sinatrarb.com/">Sinatra</a> app serves up some basic graphs and allows two commits to be compared:</p>

<p><img src="http://presidentbeef.github.com/images/blog/brakeman-graphs.png" title="Ugly, I know" alt="Brakeman Graphs" /></p>

<p>This &#8220;system&#8221; is not open source at the moment, but probably will be in the future when I&#8217;ve removed hard-coded stuff.</p>

<p>Anyhow, since I have all these reports, I can share some data&#8230;but just be forewarned you can&#8217;t really draw any conclusions from it!</p>

<h3>Numbers!</h3>

<p>This is the RethinkDB query for warnings per category, in JavaScript since I ran it in the web UI:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">r</span><span class="p">.</span><span class="nx">db</span><span class="p">(</span><span class="s2">&quot;brakeman&quot;</span><span class="p">).</span>
</span><span class='line'>  <span class="nx">table</span><span class="p">(</span><span class="s2">&quot;reports&quot;</span><span class="p">).</span>
</span><span class='line'>  <span class="nx">getAll</span><span class="p">(</span><span class="s2">&quot;25a41dfcd9171695e731533c50de573c71c63deb&quot;</span><span class="p">,</span> <span class="p">{</span><span class="nx">index</span><span class="o">:</span> <span class="s2">&quot;brakeman_sha&quot;</span><span class="p">}).</span>
</span><span class='line'>  <span class="nx">concatMap</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">rep</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">rep</span><span class="p">(</span><span class="s2">&quot;brakeman_report&quot;</span><span class="p">)(</span><span class="s2">&quot;warnings&quot;</span><span class="p">)</span> <span class="p">}).</span>
</span><span class='line'>  <span class="nx">groupBy</span><span class="p">(</span><span class="s2">&quot;warning_type&quot;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">count</span><span class="p">).</span>
</span><span class='line'>  <span class="nx">orderBy</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">desc</span><span class="p">(</span><span class="s2">&quot;reduction&quot;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>




<table>
  <tr>
    <th>
      <strong>Warning Category</strong>
    </th>
    <th>
      <strong>Count</strong>
    </th>
  </tr>
  <tr>
    <td>
      Cross Site Scripting
    </td>
    <td>
      6669
    </td>
  </tr>
  <tr>
    <td>
      Mass Assignment
    </td>
    <td>
      3385
    </td>
  </tr>
  <tr>
    <td>
      SQL Injection
    </td>
    <td>
      1353
    </td>
  </tr>
  <tr>
    <td>
      Remote Code Execution
    </td>
    <td>
      458
    </td>
  </tr>
  <tr>
    <td>
      Denial of Service
    </td>
    <td>
      440
    </td>
  </tr>
  <tr>
    <td>
      Redirect
    </td>
    <td>
      232
    </td>
  </tr>
  <tr>
    <td>
      Format Validation
    </td>
    <td>
      230
    </td>
  </tr>
  <tr>
    <td>
      Attribute Restriction
    </td>
    <td>
      205
    </td>
  </tr>
  <tr>
    <td>
      File Access
    </td>
    <td>
      200
    </td>
  </tr>
  <tr>
    <td>
      Session Setting
    </td>
    <td>
      169
    </td>
  </tr>
  <tr>
    <td>
      Dynamic Render Path
    </td>
    <td>
      140
    </td>
  </tr>
  <tr>
    <td>
      Command Injection
    </td>
    <td>
      116
    </td>
  </tr>
  <tr>
    <td>
      Cross-Site Request Forgery
    </td>
    <td>
      96
    </td>
  </tr>
  <tr>
    <td>
      Default Routes
    </td>
    <td>
      67
    </td>
  </tr>
  <tr>
    <td>
      Response Splitting
    </td>
    <td>
      44
    </td>
  </tr>
  <tr>
    <td>
      Dangerous Eval
    </td>
    <td>
      43
    </td>
  </tr>
  <tr>
    <td>
      Dangerous Send
    </td>
    <td>
      33
    </td>
  </tr>
  <tr>
    <td>
      Nested Attributes
    </td>
    <td>
      5
    </td>
  </tr>
  <tr>
    <td>
      Information Disclosure
    </td>
    <td>
      2
    </td>
  </tr>
  <tr>
    <td>
      Authentication
    </td>
    <td>
      2
    </td>
  </tr>
</table>


<br>


<p>Some educated guesses about these numbers:</p>

<ul>
<li>Mass assignment numbers are likely high because they include warnings about dangerous attributes that are whitelisted.</li>
<li>Remote code injection is mostly uses of <code>constantize</code> and similar methods.</li>
<li>Most denial of service warnings are calls to <code>to_sym</code> on parameters</li>
<li>Response splitting is interesting because it is only reported in regards to <a href="https://groups.google.com/d/msg/rubyonrails-security/b_yTveAph2g/jKe6OuRC47sJ">CVE-2011-3186</a> which was fixed in Rails 2.3.13.</li>
</ul>


<p>This last point made me curious about the Rails versions in use by the applications. Keeping in mind these apps are not necessarily up-to-date, they represent at least 37 different versions! Some were reported as unknown versions.</p>

<p>Here are the top ten:</p>

<table>
  <tr>
    <th>
      <strong>Rails Version</strong>
    </th>
    <th>
      <strong>Count</strong>
    </th>
  </tr>
  <tr>
    <td>
      3.2.13
    </td>
    <td>
      26
    </td>
  </tr>
  <tr>
    <td>
      2.3.5
    </td>
    <td>
      19
    </td>
  </tr>
  <tr>
    <td>
      3.0.3
    </td>
    <td>
      18
    </td>
  </tr>
  <tr>
    <td>
      3.2.14
    </td>
    <td>
      14
    </td>
  </tr>
  <tr>
    <td>
      4.0.0
    </td>
    <td>
      11
    </td>
  </tr>
  <tr>
    <td>
      3.2.12
    </td>
    <td>
      9
    </td>
  </tr>
  <tr>
    <td>
      2.3.8
    </td>
    <td>
      8
    </td>
  </tr>
  <tr>
    <td>
      3.2.11
    </td>
    <td>
      8
    </td>
  </tr>
  <tr>
    <td>
      3.0.0
    </td>
    <td>
      7
    </td>
  </tr>
  <tr>
    <td>
      3.1.0
    </td>
    <td>
      6
    </td>
  </tr>
</table>


<br>


<p>With so many applications and nearly 14,000 warnings, there is a lot more information to go through here.</p>

<p>For now this process is used to help test new Brakeman code and avoid regressions. It&#8217;s stopped quite a few bugs from going out!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast Compact Sparse Bit Sets]]></title>
    <link href="http://presidentbeef.github.com/blog/2013/09/02/fast-compact-sparse-bitsets/"/>
    <updated>2013-09-02T14:49:00-07:00</updated>
    <id>http://presidentbeef.github.com/blog/2013/09/02/fast-compact-sparse-bitsets</id>
    <content type="html"><![CDATA[<p>Imagine you need a relatively compact data structure for quickly checking membership of mostly-consecutive non-negative integers. (If this sounds really specific, it is because it is precisely what I needed for a particular project.)</p>

<p>The Ruby standard library contains a <a href="http://rdoc.info/stdlib/set/1.9.3/Set">Set</a> class which may be a good starting point. Set is actually implemented as a Hash with the Set elements as keys and <code>true</code> as the values. Thus the overhead for storing a value in the Set is essentially only the value itself since all keys point to the same <code>true</code> object. Assuming a 64-bit machine, the overhead will be 64 bits per value. This seems reasonable, but given the specific limitations of the values we wish to store, perhaps we can do better?</p>

<h3>Bit Sets</h3>

<p>A bit set is a compact data structure of binary values where membership is indicated by setting a bit to 1. The position of the bit indicates the element value. For example, the second bit from the right might be used to indicate whether or not the value 1 is in the set.</p>

<p>One method to determine membership is to AND the bit set with a mask with only the desired bit set to 1. If the result is 0, the value is not in the set. If it is any other result (actually the mask itself, but the zero check is sufficinet), the value is a member of the set.</p>

<p>In Ruby, this looks like</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">bitset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<p>For example, to check if the value 4 is in the set, we use the mask <code>00010000</code> (the 5th bit from the right is set to 1) which is the decimal value <code>8</code>:</p>

<p><img src="http://presidentbeef.github.com/images/blog/bitset-example1.png" alt="Bit Set Checking Example 1" /></p>

<p>Since the result is zero, we know the value 4 is not in the set.</p>

<p>If we check for the value <code>6</code>, the result is not zero, indicating the value is a member of the set:</p>

<p><img src="http://presidentbeef.github.com/images/blog/bitset-example2.png" alt="Bit Set Checking Example 2" /></p>

<p>Now, instead of 64 bits per value, it only requires a single bit! Now we just need to put a lot of bits together, either by using a long string or a bunch of integers in an array.</p>

<h3>Sparse Bit Sets</h3>

<p>The problem with a long binary string or an array of integers is that membership is entirely position-based. To store the value <code>1000</code>, the data structure requires 1001 bits, all but one of which is set to 0. This is quite inefficient, especially for very large values.</p>

<p>One solution is to create a sparse bit set by combining a hash table with bit sets as values. The hash table keys provide fast look up of the correct bit set, then the bit set is checked for the desired element. The keys indicate the lowest value stored in the bit set (e.g., the decimal key <code>4</code> pointing to the binary bit set <code>00000001</code> would mean the value <code>4</code> is in the set).</p>

<p>Below is an example of a hash table using integer keys and 8 bit integers for the bit sets:</p>

<p><img src="http://presidentbeef.github.com/images/blog/sparse-bitset-example.png" alt="Sparse Bit Set Example" /></p>

<p>The average overhead is <code>⌊(m * n) / w⌋ + m</code> bits, where <em>m</em> is the number of values (assumed to be consecutive), <em>w</em> is the number of bits per bit set, and <em>n</em> is the number of bits per key. In 64-bit Ruby, if we use integers for the bit sets, <em>n</em> = 64 and <em>w</em> = 62<a href="#footnote">*</a>. This works out to an average of 2 bits per value in the set. Of course, a single value incurs the overhead of both the key and the bit set: 128 bits! But if there are many consecutive values, the cost per value begins to shrink. For example, the numbers 0 to 61 can be stored in a single bit set, so 62 values can be stored in the 128 bits and we are back to about 2 bits per value.</p>

<p>Note that while it is best to use consecutive values which fit neatly into the bit sets (in this case, runs of 62 integers), the sequences can start and end at arbitrary points with only a little &#8220;wasted&#8221; overhead. To store just the number <code>1000</code>, we now only need 128 bits, not 1001.</p>

<p>On top of the space savings, the membership checks remain fast. Still assuming 64-bit Ruby, to determine if a value is in the table look up index <code>i = value / 61</code>. Then check the bit set with <code>bitset &amp; (1 &lt;&lt; (value % 61) != 0</code> as previously. (The divisor is 61 because there are 62 bits, but the values are 0 to 61).</p>

<h3>Space Efficiency</h3>

<p>I have implemented a Ruby version of the data structure described above which I call the <a href="https://github.com/presidentbeef/dumb-numb-set">Dumb Numb Set</a> (DNS).</p>

<p>To measure the space used by the bit sets, we compare the Marshal data size for the bit sets versus regular Hashes (using <code>true</code> for all values, just like a Ruby Set).</p>

<p>These are the results for perfectly ordered data on a 64-bit version of Ruby 1.9.3 (size is number of bytes):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Items</span>        <span class="no">Hash</span>         <span class="no">DNS</span>      <span class="o">%</span><span class="n">reduction</span>
</span><span class='line'><span class="o">---------------------------------------------</span>
</span><span class='line'>   <span class="mi">1</span>   <span class="o">|</span>           <span class="mi">7</span>  <span class="o">|</span>        <span class="mi">41</span>   <span class="o">|-</span><span class="mi">486</span><span class="o">%</span>
</span><span class='line'> <span class="mi">100</span>   <span class="o">|</span>         <span class="mi">307</span>  <span class="o">|</span>        <span class="mi">61</span>   <span class="o">|</span>  <span class="mi">80</span><span class="o">%</span>
</span><span class='line'>  <span class="mi">1</span><span class="n">k</span>   <span class="o">|</span>        <span class="mi">4632</span>  <span class="o">|</span>       <span class="mi">253</span>   <span class="o">|</span>  <span class="mi">95</span><span class="o">%</span>
</span><span class='line'> <span class="mi">10</span><span class="n">k</span>   <span class="o">|</span>       <span class="mi">49632</span>  <span class="o">|</span>      <span class="mi">2211</span>   <span class="o">|</span>  <span class="mi">96</span><span class="o">%</span>
</span><span class='line'><span class="mi">100</span><span class="n">k</span>   <span class="o">|</span>      <span class="mi">534098</span>  <span class="o">|</span>     <span class="mi">24254</span>   <span class="o">|</span>  <span class="mi">95</span><span class="o">%</span>
</span><span class='line'>  <span class="mi">1</span><span class="n">M</span>   <span class="o">|</span>     <span class="mi">5934098</span>  <span class="o">|</span>    <span class="mi">245565</span>   <span class="o">|</span>  <span class="mi">96</span><span class="o">%</span>
</span><span class='line'> <span class="mi">10</span><span class="n">M</span>   <span class="o">|</span>    <span class="mi">59934098</span>  <span class="o">|</span>   <span class="mi">2557080</span>   <span class="o">|</span>  <span class="mi">96</span><span class="o">%</span>
</span><span class='line'><span class="mi">100</span><span class="n">M</span>   <span class="o">|</span>   <span class="mi">683156884</span>  <span class="o">|</span>  <span class="mi">26163639</span>   <span class="o">|</span>  <span class="mi">96</span><span class="o">%</span>
</span><span class='line'>  <span class="mi">1</span><span class="n">B</span>   <span class="o">|</span>         <span class="p">?</span>    <span class="o">|</span> <span class="mi">262229211</span>   <span class="o">|</span>   <span class="p">?</span>
</span><span class='line'><span class="o">---------------------------------------------</span>
</span></code></pre></td></tr></table></div></figure>


<p>At 1 billion items, my machine ran out of memory.</p>

<p>For a single item, as expected, overhead in the DNS is quite high. But for as little as 100 items in the set, the DNS is considerably more compact.</p>

<p>This is, however, the best case scenario for the DNS. Less perfectly dense values cause it to <a href="https://github.com/presidentbeef/dumb-numb-set#less-dense-data">be less efficient</a>. For <em>very</em> sparse values, a Hash/Set is probably a better choice.</p>

<h3>Even Better Space Efficiency</h3>

<p>It may not surprise you to find out I was very interested in minimizing the serialized version of the sparse bit set for sending it over a network. In investigating easy but compact ways of doing so, I realized the Marshal data for Hashes and integers is not very compact, especially for large integers.</p>

<p>Fortunately, there is an existing solution for this scenario called <a href="http://msgpack.org/">MessagePack</a>. For storing 1 million values, serialized size is reduced from 245,565 to 196,378 bytes (20%). The DNS will use MessagePack automatically if it is installed.</p>

<h3>Performance</h3>

<p>Somewhat surprisingly, the DNS is quite fast even when compared to MRI Ruby&#8217;s Hash implementation.</p>

<p>With MRI Ruby 1.9.3p448 (x86_64) and 1 million values:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>                           <span class="n">user</span>     <span class="nb">system</span>      <span class="n">total</span>        <span class="n">real</span>
</span><span class='line'><span class="no">Hash</span> <span class="n">add</span> <span class="n">random</span>            <span class="mi">0</span><span class="o">.</span><span class="mi">540000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">020000</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">560000</span> <span class="p">(</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">549499</span><span class="p">)</span>
</span><span class='line'><span class="no">DumbNumbSet</span> <span class="n">add</span> <span class="n">random</span>     <span class="mi">0</span><span class="o">.</span><span class="mi">850000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">020000</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">870000</span> <span class="p">(</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">864700</span><span class="p">)</span>
</span><span class='line'><span class="no">Hash</span> <span class="n">add</span> <span class="k">in</span> <span class="n">order</span>          <span class="mi">0</span><span class="o">.</span><span class="mi">540000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">020000</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">560000</span> <span class="p">(</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">556441</span><span class="p">)</span>
</span><span class='line'><span class="no">DumbNumbSet</span> <span class="n">add</span> <span class="k">in</span> <span class="n">order</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">490000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">000000</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">490000</span> <span class="p">(</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">483713</span><span class="p">)</span>
</span><span class='line'><span class="no">Hash</span> <span class="n">add</span> <span class="n">shuffled</span>          <span class="mi">0</span><span class="o">.</span><span class="mi">570000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">020000</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">590000</span> <span class="p">(</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">589316</span><span class="p">)</span>
</span><span class='line'><span class="no">DumbNumbSet</span> <span class="n">add</span> <span class="n">shuffled</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">540000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">010000</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">550000</span> <span class="p">(</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">538420</span><span class="p">)</span>
</span><span class='line'><span class="no">Hash</span> <span class="n">look</span> <span class="n">up</span>               <span class="mi">0</span><span class="o">.</span><span class="mi">930000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">010000</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">940000</span> <span class="p">(</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">940849</span><span class="p">)</span>
</span><span class='line'><span class="no">DNS</span> <span class="n">look</span> <span class="n">up</span>                <span class="mi">0</span><span class="o">.</span><span class="mi">820000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">000000</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">820000</span> <span class="p">(</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">818728</span><span class="p">)</span>
</span><span class='line'><span class="no">Hash</span> <span class="n">remove</span>                <span class="mi">0</span><span class="o">.</span><span class="mi">980000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">030000</span>   <span class="mi">1</span><span class="o">.</span><span class="mo">010000</span> <span class="p">(</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">999362</span><span class="p">)</span>
</span><span class='line'><span class="no">DNS</span> <span class="n">remove</span>                 <span class="mi">0</span><span class="o">.</span><span class="mi">950000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">000000</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">950000</span> <span class="p">(</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">953170</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The only operation slower than a regular Hash is inserting many random values. All other operations are roughly equal.</p>

<h3>Conclusion</h3>

<p>For my specific scenario, a simple custom data structure was just as fast as a built-in data structure, but required significantly less space for the expected use case.</p>

<p>There are other solutions for this type of problem, but it should be noted I only really care about fast insertion, fast membership checks, and compact representation. Additionally, values may be very large, although I attempt to keep them within the Fixnum range for Ruby (i.e. less than 2<sup>62</sup> - 1). This rules out some implementations which require arrays the size of the maximum value!</p>

<p>I also did not want to deal with compression schemes, of which there are quite a few, since my sets were going to be dynamic. I imagine there are very efficient implementations for fixed data sets.</p>

<p><a name="footnote"></a></p>

<h4>Footnote: Integer Size in Ruby</h4>

<p>Integers in 32-bit MRI Ruby only have 30 bits available, and in 64-bit MRI Ruby they only have 62 bits available:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">irb</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p448</span> <span class="p">:</span><span class="mo">001</span> <span class="o">&gt;</span> <span class="p">(</span><span class="s2">&quot;1&quot;</span> <span class="o">*</span> <span class="mi">62</span><span class="p">)</span><span class="o">.</span><span class="n">to_i</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">class</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="no">Fixnum</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p448</span> <span class="p">:</span><span class="mo">002</span> <span class="o">&gt;</span> <span class="p">(</span><span class="s2">&quot;1&quot;</span> <span class="o">*</span> <span class="mi">63</span><span class="p">)</span><span class="o">.</span><span class="n">to_i</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">class</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="no">Bignum</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Avoiding SQL Injection in Rails]]></title>
    <link href="http://presidentbeef.github.com/blog/2013/02/08/avoid-sql-injection-in-rails/"/>
    <updated>2013-02-08T09:45:00-08:00</updated>
    <id>http://presidentbeef.github.com/blog/2013/02/08/avoid-sql-injection-in-rails</id>
    <content type="html"><![CDATA[<p>SQL injection (SQLi) is any situation in which a user can manipulate a database query in an unintended manner. Consequences of SQL injection vulnerabilites range from data leaks, to authentication bypass, to root access on a database server. In short, it is a very big deal.</p>

<p>Most Rails applications interact with a database through ActiveRecord, the default and convenient Object Relational Mapping (ORM) layer which comes with Rails.
Generally, use of ORMs is safer than not. They can provide abstraction and safety and allow developers to avoid manually building SQL queries. They can embody best practices and prevent careless handling of external input.</p>

<p>Instead of unsafe code like</p>

<pre><code>query = "SELECT * FROM users WHERE name = '#{name}' AND password = '#{password'} LIMIT 1"
results = DB.execute(query)
</code></pre>

<p>You can have safer, simpler code like</p>

<pre><code>User.where(:name =&gt; name, :password =&gt; :password).first
</code></pre>

<p>My impression is many people assume the Rails framework will protect them as long as they avoid the &#8220;obviously dangerous&#8221; methods, like <code>find_by_sql</code>.</p>

<p>Unfortunately, ActiveRecord is unsafe more often than it is safe. It does provide parameterization of queries (the API documentation for which can be <a href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html">found here</a>) for some methods, there are many methods for which it does not. While these methods are not intended to be used with user input, the truth is that has never stopped anyone.</p>

<p>To make it clear how dangerous it can be to use ActiveRecord, consider <a href="http://api.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-exists-3F">ActiveRecord::FinderMethods#exists?</a> which queries the database and returns <code>true</code> if a matching record exists. The argument can be a primary key (either integer or string, if a string it will be sanitized), an array consisting of a template string and values to safely interpolate, or a hash of column-value pairs (which will be sanitized).</p>

<p>Here is an example of using <code>exists?</code> to determine if a given user exists:</p>

<pre><code>User.exists? params[:user_id]
</code></pre>

<p>This looks harmless, since <code>params[:user_id]</code> is a string, and strings will be sanitized. In fact, the documentation clearly points out not to pass in conditions as strings, because they will be escaped.</p>

<p>However, there is no gaurantee <code>params[:user_id]</code> is a string. An attacker could send a request with <code>?user_id[]=some_attack_string</code>, which Rails will turn into an array <code>["some_attack_string"]</code>. Now the argument is an array, the first element of which is not escaped.</p>

<p>To avoid this problem, the user input should be converted to the expected type:</p>

<pre><code>User.exists? params[:user_id].to_i
</code></pre>

<p>Or use a hash:</p>

<pre><code>User.exists? :id =&gt; params[:user_id]
</code></pre>

<p>This should be the approach for all uses of user input. Do not assume <em>anything</em> about values from external sources or what safety mechanisms a method might have.</p>

<p>While working on <a href="http://brakemanscanner.org/">Brakeman</a>, I thought it would be useful to put together a list of all the unsafe ways one can use ActiveRecord.</p>

<p>To make it easier on myself, I built the list into a Rails application so I could easily test, verify, and record any findings. The source is <a href="https://github.com/presidentbeef/inject-some-sql">available here</a> for those who would like try out the examples. The application is a single page of all the queries and example injections. From there one can submit queries and see the results:</p>

<p><img src="http://presidentbeef.github.com/images/blog/inject-some-sql.png" alt="Query Example" /></p>

<p>The resulting information is available at <a href="http://rails-sqli.org">rails-sqli.org</a>, including examples of how SQL injection can occur and the resulting queries. This is basically a big list of what <em>not</em> to do when using ActiveRecord. Again, please feel free to <a href="https://github.com/presidentbeef/inject-some-sql">contribute</a> so that the list can be as authoritative as possible and help everyone avoid SQL injection in Rails.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Faster Call Indexing in Brakeman]]></title>
    <link href="http://presidentbeef.github.com/blog/2012/11/28/faster-call-indexing-in-brakeman-1-dot-8-3/"/>
    <updated>2012-11-28T11:49:00-08:00</updated>
    <id>http://presidentbeef.github.com/blog/2012/11/28/faster-call-indexing-in-brakeman-1-dot-8-3</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>About a month ago, an <a href="https://github.com/presidentbeef/brakeman/issues/171">issue</a> was reported where <a href="http://brakemanscanner.org">Brakeman</a> taking a ridiculously long time on the &#8220;call indexing&#8221; step. At the time, I was pessimistic about opportunities to improve the performance of call indexing, since it is a pretty simple operation.</p>

<h3>Call Indexing</h3>

<p>The majority of the checks performed by Brakeman involve finding and examining method calls (e.g., SQL queries). In order to make these checks faster, Brakeman scans an app once and then saves information about each method call in a data structure called the &#8220;call index&#8221;. This makes searching for specific method calls very fast.</p>

<p>The call index allows search for methods by name and also by the class of the target. For example, it is possible to search for all calls to <code>open</code> on <code>File</code>. It also allows searching via regular expressions for methods and targets.</p>

<h2>Investigation</h2>

<p>I happened to notice a Rails application in my collection which also seemed to take a long time indexing calls. So I ran it through <a href="https://github.com/tmm1/perftools.rb">perftools.rb</a> to see if there was anything interesting going on.</p>

<p>This is the result:</p>

<p><a href="http://presidentbeef.github.com/images/blog/brakeman-scan-1.8.2.pdf"><img src="http://presidentbeef.github.com/images/blog/brakeman-scan-1.8.2.png" alt="Brakeman 1.8.2 scan" /></a></p>

<p>The large amount of time spent in the garbage collector (60%) was high even for Brakeman. But then something else caught my eye:</p>

<p><img src="http://presidentbeef.github.com/images/blog/call-indexing-1.8.2.png" alt="Call indexing in 1.8.2" /></p>

<p>This scan spent 4.7% of its time converting <code>Sexp</code>s to strings while indexing calls. This seemed excessive.</p>

<p>This is the entirety of the call indexing code:</p>

<figure class='code'><figcaption><span>call_index.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">index_calls</span> <span class="n">calls</span>
</span><span class='line'>    <span class="n">calls</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">call</span><span class="o">|</span>
</span><span class='line'>      <span class="vi">@methods</span> <span class="o">&lt;&lt;</span> <span class="n">call</span><span class="o">[</span><span class="ss">:method</span><span class="o">].</span><span class="n">to_s</span>
</span><span class='line'>      <span class="vi">@targets</span> <span class="o">&lt;&lt;</span> <span class="n">call</span><span class="o">[</span><span class="ss">:target</span><span class="o">].</span><span class="n">to_s</span>
</span><span class='line'>      <span class="vi">@calls_by_method</span><span class="o">[</span><span class="n">call</span><span class="o">[</span><span class="ss">:method</span><span class="o">]]</span> <span class="o">&lt;&lt;</span> <span class="n">call</span>
</span><span class='line'>      <span class="vi">@calls_by_target</span><span class="o">[</span><span class="n">call</span><span class="o">[</span><span class="ss">:target</span><span class="o">]]</span> <span class="o">&lt;&lt;</span> <span class="n">call</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>@methods</code> and <code>@targets</code> are sets which contain the string versions of all the methods and method targets. This is <em>exclusively</em> used to search for methods and targets via regular expressions.</p>

<p>The call method will always be a symbol&#8230;but what about the target? It turns out that while much of the time it is a symbol, if a sane value like <code>:File</code> or <code>:@something</code> cannot be found, then it will be the entire <code>Sexp</code>! This is where Brakeman was wasting time calling <code>Sexp#to_s</code>.</p>

<p>The quick fix was to only store symbol targets in the <code>@targets</code> set, ignoring any other target values.</p>

<h2>Results</h2>

<p>Scanning the same application with Brakeman 1.8.3 has this result:</p>

<p><a href="http://presidentbeef.github.com/images/blog/brakeman-scan-1.8.3.pdf"><img src="http://presidentbeef.github.com/images/blog/brakeman-scan-1.8.3.png" alt="Brakeman 1.8.3 scan" /></a></p>

<p>Garbage collection time dropped from 60% to 42%. While still very high, this is a good sign. Time spent indexing calls has dropped from 5.4% to 1.8% and the calls to <code>Sexp#to_s</code> have vanished.</p>

<p>The total scan time dropped from 3.5 minutes to about 2 minutes. For the original reporter, scan times went from <a href="https://github.com/presidentbeef/brakeman/issues/171#issuecomment-10344355">78 minutes to 40 <em>seconds</em></a>.</p>

<h2>More Improvements</h2>

<p>Looking through Brakeman, it does not currently use the &#8220;search via regex&#8221; feature for the call index. So the method and target name sets can be removed entirely.</p>

<p>Going even further, nowhere does Brakeman search for targets by any values other than symbols. Note in the graph below that <code>Array#eql?</code> was sampled 1,330 times during call indexing:</p>

<p><img src="http://presidentbeef.github.com/images/blog/call-indexing-hashing-sexp.png" alt="Call indexing hashing" /></p>

<p>Since <code>Sexp</code>s are subclassed from <code>Array</code>, it is clear that these calls are generated when using the <code>call[:target]</code> as a hash key (line 6 above). Again, the current Brakeman code only searches for call targets by symbol, never by a full <code>Sexp</code>. There is no reason to the call targets that are <code>Sexp</code>s.</p>

<p>This is the modified call indexing code:</p>

<figure class='code'><figcaption><span>Modified call_index.rb</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">index_calls</span> <span class="n">calls</span>
</span><span class='line'>    <span class="n">calls</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">call</span><span class="o">|</span>
</span><span class='line'>      <span class="vi">@calls_by_method</span><span class="o">[</span><span class="n">call</span><span class="o">[</span><span class="ss">:method</span><span class="o">]]</span> <span class="o">&lt;&lt;</span> <span class="n">call</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">unless</span> <span class="n">call</span><span class="o">[</span><span class="ss">:target</span><span class="o">].</span><span class="n">is_a?</span> <span class="no">Sexp</span>
</span><span class='line'>        <span class="vi">@calls_by_target</span><span class="o">[</span><span class="n">call</span><span class="o">[</span><span class="ss">:target</span><span class="o">]]</span> <span class="o">&lt;&lt;</span> <span class="n">call</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>With this code in place, call indexing does not even show up under perftools. Speed improvements vary by project, but this should at least shave off a few seconds. <a href="https://github.com/presidentbeef/brakeman/pull/189#issuecomment-10768297">YMMV</a>.</p>

<h2>Wrapping Up</h2>

<p>Some quick profiling led me to performance improvements where I really did not expect to find them. Sadly, this is one of the cleanest, simplest parts of Brakeman, so I know there are many other instances where Brakeman can be improved. Prior to the introduction of the call index in Brakeman 1.0, I was trying to keep Brakeman scans under 20 minutes (on large applications). Now I worry when scans take longer than a few minutes.</p>

<p>97% of the open source Rails applications I use as test cases can be scanned in less than 30 seconds. Unfortunately, this probably does not reflect scan times for large, commercial applications. Please <a href="https://github.com/presidentbeef/brakeman/issues">report</a> any long-running scans! It may lead to more speed improvements like the ones above.</p>
]]></content>
  </entry>
  
</feed>
